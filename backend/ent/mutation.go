// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/B6001186/app/ent/department"
	"github.com/B6001186/app/ent/employee"
	"github.com/B6001186/app/ent/place"
	"github.com/B6001186/app/ent/titlename"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDepartment = "Department"
	TypeEmployee   = "Employee"
	TypePlace      = "Place"
	TypeTitlename  = "Titlename"
)

// DepartmentMutation represents an operation that mutate the Departments
// nodes in the graph.
type DepartmentMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_Name           *string
	clearedFields   map[string]struct{}
	employee        map[int]struct{}
	removedemployee map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Department, error)
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows to manage the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for $n.Name.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the id field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the Name field.
func (m *DepartmentMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the Name value in the mutation.
func (m *DepartmentMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old Name value of the Department.
// If the Department object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepartmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "Name" field.
func (m *DepartmentMutation) ResetName() {
	m._Name = nil
}

// AddEmployeeIDs adds the employee edge to Employee by ids.
func (m *DepartmentMutation) AddEmployeeIDs(ids ...int) {
	if m.employee == nil {
		m.employee = make(map[int]struct{})
	}
	for i := range ids {
		m.employee[ids[i]] = struct{}{}
	}
}

// RemoveEmployeeIDs removes the employee edge to Employee by ids.
func (m *DepartmentMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployee == nil {
		m.removedemployee = make(map[int]struct{})
	}
	for i := range ids {
		m.removedemployee[ids[i]] = struct{}{}
	}
}

// RemovedEmployee returns the removed ids of employee.
func (m *DepartmentMutation) RemovedEmployeeIDs() (ids []int) {
	for id := range m.removedemployee {
		ids = append(ids, id)
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
func (m *DepartmentMutation) EmployeeIDs() (ids []int) {
	for id := range m.employee {
		ids = append(ids, id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *DepartmentMutation) ResetEmployee() {
	m.employee = nil
	m.removedemployee = nil
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Name != nil {
		fields = append(fields, department.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employee != nil {
		edges = append(edges, department.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeEmployee:
		ids := make([]ent.Value, 0, len(m.employee))
		for id := range m.employee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedemployee != nil {
		edges = append(edges, department.EdgeEmployee)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeEmployee:
		ids := make([]ent.Value, 0, len(m.removedemployee))
		for id := range m.removedemployee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// EmployeeMutation represents an operation that mutate the Employees
// nodes in the graph.
type EmployeeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_User_id          *string
	_Name             *string
	_Tel              *string
	_Email            *string
	_BirthdayDate     *time.Time
	_AttendTime       *time.Time
	_FinishTime       *time.Time
	clearedFields     map[string]struct{}
	department        *int
	cleareddepartment bool
	place             *int
	clearedplace      bool
	titlename         *int
	clearedtitlename  bool
	done              bool
	oldValue          func(context.Context) (*Employee, error)
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows to manage the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for $n.Name.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the id field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserID sets the User_id field.
func (m *EmployeeMutation) SetUserID(s string) {
	m._User_id = &s
}

// UserID returns the User_id value in the mutation.
func (m *EmployeeMutation) UserID() (r string, exists bool) {
	v := m._User_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old User_id value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID reset all changes of the "User_id" field.
func (m *EmployeeMutation) ResetUserID() {
	m._User_id = nil
}

// SetName sets the Name field.
func (m *EmployeeMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the Name value in the mutation.
func (m *EmployeeMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old Name value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "Name" field.
func (m *EmployeeMutation) ResetName() {
	m._Name = nil
}

// SetTel sets the Tel field.
func (m *EmployeeMutation) SetTel(s string) {
	m._Tel = &s
}

// Tel returns the Tel value in the mutation.
func (m *EmployeeMutation) Tel() (r string, exists bool) {
	v := m._Tel
	if v == nil {
		return
	}
	return *v, true
}

// OldTel returns the old Tel value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldTel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTel: %w", err)
	}
	return oldValue.Tel, nil
}

// ResetTel reset all changes of the "Tel" field.
func (m *EmployeeMutation) ResetTel() {
	m._Tel = nil
}

// SetEmail sets the Email field.
func (m *EmployeeMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the Email value in the mutation.
func (m *EmployeeMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old Email value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "Email" field.
func (m *EmployeeMutation) ResetEmail() {
	m._Email = nil
}

// SetBirthdayDate sets the BirthdayDate field.
func (m *EmployeeMutation) SetBirthdayDate(t time.Time) {
	m._BirthdayDate = &t
}

// BirthdayDate returns the BirthdayDate value in the mutation.
func (m *EmployeeMutation) BirthdayDate() (r time.Time, exists bool) {
	v := m._BirthdayDate
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthdayDate returns the old BirthdayDate value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldBirthdayDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBirthdayDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBirthdayDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthdayDate: %w", err)
	}
	return oldValue.BirthdayDate, nil
}

// ResetBirthdayDate reset all changes of the "BirthdayDate" field.
func (m *EmployeeMutation) ResetBirthdayDate() {
	m._BirthdayDate = nil
}

// SetAttendTime sets the AttendTime field.
func (m *EmployeeMutation) SetAttendTime(t time.Time) {
	m._AttendTime = &t
}

// AttendTime returns the AttendTime value in the mutation.
func (m *EmployeeMutation) AttendTime() (r time.Time, exists bool) {
	v := m._AttendTime
	if v == nil {
		return
	}
	return *v, true
}

// OldAttendTime returns the old AttendTime value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldAttendTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAttendTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAttendTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttendTime: %w", err)
	}
	return oldValue.AttendTime, nil
}

// ResetAttendTime reset all changes of the "AttendTime" field.
func (m *EmployeeMutation) ResetAttendTime() {
	m._AttendTime = nil
}

// SetFinishTime sets the FinishTime field.
func (m *EmployeeMutation) SetFinishTime(t time.Time) {
	m._FinishTime = &t
}

// FinishTime returns the FinishTime value in the mutation.
func (m *EmployeeMutation) FinishTime() (r time.Time, exists bool) {
	v := m._FinishTime
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishTime returns the old FinishTime value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldFinishTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFinishTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFinishTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishTime: %w", err)
	}
	return oldValue.FinishTime, nil
}

// ResetFinishTime reset all changes of the "FinishTime" field.
func (m *EmployeeMutation) ResetFinishTime() {
	m._FinishTime = nil
}

// SetDepartmentID sets the department edge to Department by id.
func (m *EmployeeMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the department edge to Department.
func (m *EmployeeMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared returns if the edge department was cleared.
func (m *EmployeeMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the department id in the mutation.
func (m *EmployeeMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the department ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment reset all changes of the "department" edge.
func (m *EmployeeMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// SetPlaceID sets the place edge to Place by id.
func (m *EmployeeMutation) SetPlaceID(id int) {
	m.place = &id
}

// ClearPlace clears the place edge to Place.
func (m *EmployeeMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared returns if the edge place was cleared.
func (m *EmployeeMutation) PlaceCleared() bool {
	return m.clearedplace
}

// PlaceID returns the place id in the mutation.
func (m *EmployeeMutation) PlaceID() (id int, exists bool) {
	if m.place != nil {
		return *m.place, true
	}
	return
}

// PlaceIDs returns the place ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PlaceID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) PlaceIDs() (ids []int) {
	if id := m.place; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlace reset all changes of the "place" edge.
func (m *EmployeeMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
}

// SetTitlenameID sets the titlename edge to Titlename by id.
func (m *EmployeeMutation) SetTitlenameID(id int) {
	m.titlename = &id
}

// ClearTitlename clears the titlename edge to Titlename.
func (m *EmployeeMutation) ClearTitlename() {
	m.clearedtitlename = true
}

// TitlenameCleared returns if the edge titlename was cleared.
func (m *EmployeeMutation) TitlenameCleared() bool {
	return m.clearedtitlename
}

// TitlenameID returns the titlename id in the mutation.
func (m *EmployeeMutation) TitlenameID() (id int, exists bool) {
	if m.titlename != nil {
		return *m.titlename, true
	}
	return
}

// TitlenameIDs returns the titlename ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TitlenameID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) TitlenameIDs() (ids []int) {
	if id := m.titlename; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTitlename reset all changes of the "titlename" edge.
func (m *EmployeeMutation) ResetTitlename() {
	m.titlename = nil
	m.clearedtitlename = false
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._User_id != nil {
		fields = append(fields, employee.FieldUserID)
	}
	if m._Name != nil {
		fields = append(fields, employee.FieldName)
	}
	if m._Tel != nil {
		fields = append(fields, employee.FieldTel)
	}
	if m._Email != nil {
		fields = append(fields, employee.FieldEmail)
	}
	if m._BirthdayDate != nil {
		fields = append(fields, employee.FieldBirthdayDate)
	}
	if m._AttendTime != nil {
		fields = append(fields, employee.FieldAttendTime)
	}
	if m._FinishTime != nil {
		fields = append(fields, employee.FieldFinishTime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldUserID:
		return m.UserID()
	case employee.FieldName:
		return m.Name()
	case employee.FieldTel:
		return m.Tel()
	case employee.FieldEmail:
		return m.Email()
	case employee.FieldBirthdayDate:
		return m.BirthdayDate()
	case employee.FieldAttendTime:
		return m.AttendTime()
	case employee.FieldFinishTime:
		return m.FinishTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldUserID:
		return m.OldUserID(ctx)
	case employee.FieldName:
		return m.OldName(ctx)
	case employee.FieldTel:
		return m.OldTel(ctx)
	case employee.FieldEmail:
		return m.OldEmail(ctx)
	case employee.FieldBirthdayDate:
		return m.OldBirthdayDate(ctx)
	case employee.FieldAttendTime:
		return m.OldAttendTime(ctx)
	case employee.FieldFinishTime:
		return m.OldFinishTime(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case employee.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case employee.FieldTel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTel(v)
		return nil
	case employee.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case employee.FieldBirthdayDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthdayDate(v)
		return nil
	case employee.FieldAttendTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttendTime(v)
		return nil
	case employee.FieldFinishTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishTime(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldUserID:
		m.ResetUserID()
		return nil
	case employee.FieldName:
		m.ResetName()
		return nil
	case employee.FieldTel:
		m.ResetTel()
		return nil
	case employee.FieldEmail:
		m.ResetEmail()
		return nil
	case employee.FieldBirthdayDate:
		m.ResetBirthdayDate()
		return nil
	case employee.FieldAttendTime:
		m.ResetAttendTime()
		return nil
	case employee.FieldFinishTime:
		m.ResetFinishTime()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.department != nil {
		edges = append(edges, employee.EdgeDepartment)
	}
	if m.place != nil {
		edges = append(edges, employee.EdgePlace)
	}
	if m.titlename != nil {
		edges = append(edges, employee.EdgeTitlename)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgePlace:
		if id := m.place; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeTitlename:
		if id := m.titlename; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddepartment {
		edges = append(edges, employee.EdgeDepartment)
	}
	if m.clearedplace {
		edges = append(edges, employee.EdgePlace)
	}
	if m.clearedtitlename {
		edges = append(edges, employee.EdgeTitlename)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeDepartment:
		return m.cleareddepartment
	case employee.EdgePlace:
		return m.clearedplace
	case employee.EdgeTitlename:
		return m.clearedtitlename
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	case employee.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case employee.EdgePlace:
		m.ClearPlace()
		return nil
	case employee.EdgeTitlename:
		m.ClearTitlename()
		return nil
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case employee.EdgePlace:
		m.ResetPlace()
		return nil
	case employee.EdgeTitlename:
		m.ResetTitlename()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// PlaceMutation represents an operation that mutate the Places
// nodes in the graph.
type PlaceMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_Name           *string
	clearedFields   map[string]struct{}
	employee        map[int]struct{}
	removedemployee map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Place, error)
}

var _ ent.Mutation = (*PlaceMutation)(nil)

// placeOption allows to manage the mutation configuration using functional options.
type placeOption func(*PlaceMutation)

// newPlaceMutation creates new mutation for $n.Name.
func newPlaceMutation(c config, op Op, opts ...placeOption) *PlaceMutation {
	m := &PlaceMutation{
		config:        c,
		op:            op,
		typ:           TypePlace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaceID sets the id field of the mutation.
func withPlaceID(id int) placeOption {
	return func(m *PlaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Place
		)
		m.oldValue = func(ctx context.Context) (*Place, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Place.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlace sets the old Place of the mutation.
func withPlace(node *Place) placeOption {
	return func(m *PlaceMutation) {
		m.oldValue = func(context.Context) (*Place, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PlaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the Name field.
func (m *PlaceMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the Name value in the mutation.
func (m *PlaceMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old Name value of the Place.
// If the Place object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PlaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "Name" field.
func (m *PlaceMutation) ResetName() {
	m._Name = nil
}

// AddEmployeeIDs adds the employee edge to Employee by ids.
func (m *PlaceMutation) AddEmployeeIDs(ids ...int) {
	if m.employee == nil {
		m.employee = make(map[int]struct{})
	}
	for i := range ids {
		m.employee[ids[i]] = struct{}{}
	}
}

// RemoveEmployeeIDs removes the employee edge to Employee by ids.
func (m *PlaceMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployee == nil {
		m.removedemployee = make(map[int]struct{})
	}
	for i := range ids {
		m.removedemployee[ids[i]] = struct{}{}
	}
}

// RemovedEmployee returns the removed ids of employee.
func (m *PlaceMutation) RemovedEmployeeIDs() (ids []int) {
	for id := range m.removedemployee {
		ids = append(ids, id)
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
func (m *PlaceMutation) EmployeeIDs() (ids []int) {
	for id := range m.employee {
		ids = append(ids, id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *PlaceMutation) ResetEmployee() {
	m.employee = nil
	m.removedemployee = nil
}

// Op returns the operation name.
func (m *PlaceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Place).
func (m *PlaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PlaceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Name != nil {
		fields = append(fields, place.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PlaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case place.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PlaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case place.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Place field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PlaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case place.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Place field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PlaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PlaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PlaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Place numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PlaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PlaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Place nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PlaceMutation) ResetField(name string) error {
	switch name {
	case place.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Place field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PlaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employee != nil {
		edges = append(edges, place.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PlaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case place.EdgeEmployee:
		ids := make([]ent.Value, 0, len(m.employee))
		for id := range m.employee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PlaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedemployee != nil {
		edges = append(edges, place.EdgeEmployee)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PlaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case place.EdgeEmployee:
		ids := make([]ent.Value, 0, len(m.removedemployee))
		for id := range m.removedemployee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PlaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PlaceMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PlaceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Place unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PlaceMutation) ResetEdge(name string) error {
	switch name {
	case place.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Place edge %s", name)
}

// TitlenameMutation represents an operation that mutate the Titlenames
// nodes in the graph.
type TitlenameMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_Name           *string
	clearedFields   map[string]struct{}
	employee        map[int]struct{}
	removedemployee map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Titlename, error)
}

var _ ent.Mutation = (*TitlenameMutation)(nil)

// titlenameOption allows to manage the mutation configuration using functional options.
type titlenameOption func(*TitlenameMutation)

// newTitlenameMutation creates new mutation for $n.Name.
func newTitlenameMutation(c config, op Op, opts ...titlenameOption) *TitlenameMutation {
	m := &TitlenameMutation{
		config:        c,
		op:            op,
		typ:           TypeTitlename,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTitlenameID sets the id field of the mutation.
func withTitlenameID(id int) titlenameOption {
	return func(m *TitlenameMutation) {
		var (
			err   error
			once  sync.Once
			value *Titlename
		)
		m.oldValue = func(ctx context.Context) (*Titlename, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Titlename.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTitlename sets the old Titlename of the mutation.
func withTitlename(node *Titlename) titlenameOption {
	return func(m *TitlenameMutation) {
		m.oldValue = func(context.Context) (*Titlename, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TitlenameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TitlenameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TitlenameMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the Name field.
func (m *TitlenameMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the Name value in the mutation.
func (m *TitlenameMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old Name value of the Titlename.
// If the Titlename object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TitlenameMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "Name" field.
func (m *TitlenameMutation) ResetName() {
	m._Name = nil
}

// AddEmployeeIDs adds the employee edge to Employee by ids.
func (m *TitlenameMutation) AddEmployeeIDs(ids ...int) {
	if m.employee == nil {
		m.employee = make(map[int]struct{})
	}
	for i := range ids {
		m.employee[ids[i]] = struct{}{}
	}
}

// RemoveEmployeeIDs removes the employee edge to Employee by ids.
func (m *TitlenameMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployee == nil {
		m.removedemployee = make(map[int]struct{})
	}
	for i := range ids {
		m.removedemployee[ids[i]] = struct{}{}
	}
}

// RemovedEmployee returns the removed ids of employee.
func (m *TitlenameMutation) RemovedEmployeeIDs() (ids []int) {
	for id := range m.removedemployee {
		ids = append(ids, id)
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
func (m *TitlenameMutation) EmployeeIDs() (ids []int) {
	for id := range m.employee {
		ids = append(ids, id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *TitlenameMutation) ResetEmployee() {
	m.employee = nil
	m.removedemployee = nil
}

// Op returns the operation name.
func (m *TitlenameMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Titlename).
func (m *TitlenameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TitlenameMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Name != nil {
		fields = append(fields, titlename.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TitlenameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case titlename.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TitlenameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case titlename.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Titlename field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TitlenameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case titlename.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Titlename field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TitlenameMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TitlenameMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TitlenameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Titlename numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TitlenameMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TitlenameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TitlenameMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Titlename nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TitlenameMutation) ResetField(name string) error {
	switch name {
	case titlename.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Titlename field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TitlenameMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employee != nil {
		edges = append(edges, titlename.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TitlenameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case titlename.EdgeEmployee:
		ids := make([]ent.Value, 0, len(m.employee))
		for id := range m.employee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TitlenameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedemployee != nil {
		edges = append(edges, titlename.EdgeEmployee)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TitlenameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case titlename.EdgeEmployee:
		ids := make([]ent.Value, 0, len(m.removedemployee))
		for id := range m.removedemployee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TitlenameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TitlenameMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TitlenameMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Titlename unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TitlenameMutation) ResetEdge(name string) error {
	switch name {
	case titlename.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Titlename edge %s", name)
}
